<!DOCTYPE html>
<html lang="en" data-theme="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8086 Assembly Emulator | Amey Thakur</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üñ•Ô∏è</text></svg>">
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-editor: #1e1e1e;
            --border: #30363d;
            --text: #c9d1d9;
            --text-dim: #8b949e;
            --accent: #58a6ff;
            --success: #3fb950;
            --error: #f85149;
            --warning: #d29922;
        }

        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f6f8fa;
            --bg-editor: #ffffff;
            --border: #d0d7de;
            --text: #1f2328;
            --text-dim: #656d76;
            --accent: #0969da;
            --success: #1a7f37;
            --error: #cf222e;
            --warning: #9a6700;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #484f58;
        }

        body {
            background: var(--bg-primary);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            min-height: 100vh;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, #1c2128 100%);
            border-bottom: 1px solid var(--border);
            padding: 0 24px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .header-logo {
            font-size: 28px;
            line-height: 1;
        }

        .header-title {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .header h1 {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
            letter-spacing: -0.3px;
        }

        .header .subtitle {
            font-size: 11px;
            color: var(--text-dim);
            font-weight: 400;
        }

        .toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: var(--border);
            margin: 0 8px;
        }

        .btn {
            padding: 8px 14px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-primary);
            color: var(--text);
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.15s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            text-decoration: none;
        }

        .btn:hover {
            border-color: var(--accent);
            background: #21262d;
            transform: translateY(-1px);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--success) 0%, #2ea043 100%);
            border-color: transparent;
            color: #fff;
            box-shadow: 0 2px 8px rgba(63, 185, 80, 0.3);
        }

        .btn-primary:hover {
            box-shadow: 0 4px 12px rgba(63, 185, 80, 0.4);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--bg-primary);
            border-color: var(--border);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--error) 0%, #da3633 100%);
            border-color: transparent;
            color: #fff;
            box-shadow: 0 2px 8px rgba(248, 81, 73, 0.3);
        }

        .btn-danger:hover {
            box-shadow: 0 4px 12px rgba(248, 81, 73, 0.4);
        }

        .btn-ghost {
            background: transparent;
            border-color: transparent;
            color: var(--text-dim);
        }

        .btn-ghost:hover {
            color: var(--text);
            background: var(--bg-primary);
        }

        .theme-toggle {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 1px solid var(--border);
            background: var(--bg-primary);
            color: var(--text);
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .theme-toggle:hover {
            border-color: var(--accent);
            transform: rotate(15deg);
        }

        [data-theme="light"] .btn:hover {
            background: #e6e9ec;
        }

        [data-theme="light"] .header {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, #eaeef2 100%);
        }

        [data-theme="light"] .header h1 {
            color: #1f2328;
        }

        .main {
            display: flex;
            height: calc(100vh - 90px);
        }

        .footer {
            height: 30px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: var(--text-dim);
        }

        .footer a {
            color: var(--text-dim);
            text-decoration: none;
            margin-left: 4px;
        }

        .footer a:hover {
            color: var(--accent);
        }

        .sidebar {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            padding: 15px;
        }

        .sidebar h3 {
            font-size: 12px;
            color: var(--text-dim);
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .category {
            margin-bottom: 15px;
        }

        .category-header {
            padding: 8px 10px;
            background: var(--bg-primary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .category-header:hover {
            background: var(--border);
        }

        .category-items {
            display: none;
            padding: 5px 0 5px 15px;
        }

        .category.open .category-items {
            display: block;
        }

        .category.open .category-header::after {
            content: '‚ñº';
        }

        .category-header::after {
            content: '‚ñ∂';
            font-size: 10px;
        }

        .program-item {
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            border-radius: 4px;
            color: var(--text-dim);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .program-item:hover {
            background: var(--border);
            color: var(--text);
        }

        .editor-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .editor-header {
            padding: 8px 15px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            font-size: 13px;
            color: var(--text-dim);
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 40px;
        }

        .editor-container {
            display: flex;
            flex: 1;
            position: relative;
            overflow: hidden;
            background: var(--bg-editor);
        }

        .line-numbers {
            width: 40px;
            background: var(--bg-primary);
            color: var(--text-dim);
            text-align: right;
            padding: 15px 5px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.5;
            border-right: 1px solid var(--border);
            user-select: none;
            overflow: hidden;
        }

        .line-number {
            color: var(--text-dim);
        }

        .line-number.active {
            color: var(--accent);
            background: rgba(88, 166, 255, 0.1);
        }

        #code-editor {
            flex: 1;
            background: transparent;
            border: none;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            color: var(--text);
            resize: none;
            line-height: 1.5;
            white-space: pre;
            overflow: auto;
            tab-size: 4;
        }

        #code-editor:focus {
            outline: none;
        }

        .editor-actions {
            display: flex;
            gap: 8px;
        }

        .btn-sm {
            padding: 4px 8px;
            font-size: 11px;
            height: 24px;
        }

        .right-panel {
            width: 350px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* Constrain children to panel height */
        }

        .panel-section {
            border-bottom: 1px solid var(--border);
            padding: 15px;
        }

        .panel-section h4 {
            font-size: 12px;
            color: var(--text-dim);
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .registers {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .register {
            background: var(--bg-primary);
            padding: 8px;
            border-radius: 4px;
            text-align: center;
        }

        .register-name {
            font-size: 10px;
            color: var(--text-dim);
        }

        .register-value {
            font-size: 14px;
            font-family: monospace;
            color: var(--accent);
        }

        .flags {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .flag {
            padding: 4px 10px;
            background: var(--bg-primary);
            border-radius: 4px;
            font-size: 11px;
        }

        .flag.set {
            background: var(--success);
            color: #fff;
        }

        .output-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            /* Critical: allows flex item to shrink below content size */
            overflow: hidden;
            /* Constrain children */
        }

        #output {
            flex: 1;
            background: var(--bg-primary);
            padding: 10px;
            font-family: monospace;
            font-size: 13px;
            overflow-y: auto;
            /* Enable vertical scrolling */
            overflow-x: hidden;
            /* Hide horizontal overflow */
            white-space: pre-wrap;
            min-height: 0;
            /* Allow shrinking in flex context */
            max-height: 100%;
            /* Don't exceed parent height */
        }

        .status {
            padding: 10px 15px;
            font-size: 12px;
            color: var(--text-dim);
        }

        .status.error {
            color: var(--error);
        }

        .status.success {
            color: var(--success);
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="header-left">
            <span class="header-logo">üñ•Ô∏è</span>
            <div class="header-title">
                <h1>8086 Assembly Emulator</h1>
                <p class="subtitle">Interactive Intel 8086 Microprocessor Simulator</p>
            </div>
        </div>
        <div class="toolbar">
            <button class="btn btn-primary" onclick="compileCode()">‚öô Compile</button>
            <button class="btn btn-secondary" onclick="runCode()">‚ñ∂ Run</button>
            <button class="btn btn-secondary" onclick="stepCode()">‚è≠ Step</button>
            <button class="btn btn-danger" onclick="resetEmulator()">‚ü≥ Reset</button>
            <div class="toolbar-divider"></div>
            <a href="https://github.com/Amey-Thakur/8086-ASSEMBLY-LANGUAGE-PROGRAMS" class="btn btn-ghost"
                target="_blank">
                ‚≠ê GitHub
            </a>
            <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
                <span id="theme-icon">üåô</span>
            </button>
        </div>
    </div>
    <div class="main">
        <div class="sidebar">
            <h3>üìÅ Program Library (161)</h3>
            <div id="program-list"></div>
        </div>
        <div class="editor-panel">
            <div class="editor-header">
                <div>üìù Code Editor ‚Äî <span id="current-file">hello_world_dos.asm</span></div>
                <div class="editor-actions">
                    <button class="btn btn-secondary btn-sm" onclick="copyCode()" title="Copy to Clipboard">üìã
                        Copy</button>
                    <button class="btn btn-secondary btn-sm" onclick="downloadCode()" title="Download .asm file">üíæ
                        Download</button>
                </div>
            </div>
            <div class="editor-container">
                <div class="line-numbers" id="line-numbers"></div>
                <textarea id="code-editor" spellcheck="false" oninput="updateLineNumbers()" onscroll="syncScroll()">; 8086 Assembly - Hello World
; Click a program from the sidebar to load it

ORG 100H

START:
    MOV AH, 09H         ; DOS: display string
    LEA DX, MSG         ; Load address of string
    INT 21H             ; Execute interrupt

    MOV AH, 4CH         ; DOS: terminate program
    INT 21H             ; Execute

MSG DB 'Hello, World!', 0DH, 0AH, '$'
</textarea>
            </div>
        </div>
        <div class="right-panel">
            <div class="panel-section">
                <h4>üìä Registers</h4>
                <div class="registers">
                    <div class="register">
                        <div class="register-name">AX</div>
                        <div class="register-value" id="reg-ax">0000</div>
                    </div>
                    <div class="register">
                        <div class="register-name">BX</div>
                        <div class="register-value" id="reg-bx">0000</div>
                    </div>
                    <div class="register">
                        <div class="register-name">CX</div>
                        <div class="register-value" id="reg-cx">0000</div>
                    </div>
                    <div class="register">
                        <div class="register-name">DX</div>
                        <div class="register-value" id="reg-dx">0000</div>
                    </div>
                    <div class="register">
                        <div class="register-name">SI</div>
                        <div class="register-value" id="reg-si">0000</div>
                    </div>
                    <div class="register">
                        <div class="register-name">DI</div>
                        <div class="register-value" id="reg-di">0000</div>
                    </div>
                    <div class="register">
                        <div class="register-name">SP</div>
                        <div class="register-value" id="reg-sp">FFFE</div>
                    </div>
                    <div class="register">
                        <div class="register-name">BP</div>
                        <div class="register-value" id="reg-bp">0000</div>
                    </div>
                </div>
            </div>
            <div class="panel-section">
                <h4>üö© Flags</h4>
                <div class="flags">
                    <span class="flag" id="flag-cf">CF</span>
                    <span class="flag" id="flag-zf">ZF</span>
                    <span class="flag" id="flag-sf">SF</span>
                    <span class="flag" id="flag-of">OF</span>
                    <span class="flag" id="flag-pf">PF</span>
                    <span class="flag" id="flag-af">AF</span>
                </div>
            </div>
            <div class="panel-section output-section">
                <h4>üíª Output Console</h4>
                <div id="output"></div>
            </div>
            <div class="status" id="status">Ready. Select a program or write your own code.</div>
        </div>
    </div>
    <div class="footer">
        Created by &nbsp;<a href="https://github.com/Amey-Thakur" target="_blank">Amey Thakur</a>&nbsp; ¬© 2021
    </div>

    <script>
        // 8086 Emulator Core
        class Emulator8086 {
            constructor() {
                this.reset();
            }

            reset() {
                // 16-bit registers
                this.regs = { AX: 0, BX: 0, CX: 0, DX: 0, SI: 0, DI: 0, SP: 0xFFFE, BP: 0 };
                // Flags
                this.flags = { CF: 0, ZF: 0, SF: 0, OF: 0, PF: 0, AF: 0 };
                // Memory (64KB)
                this.memory = new Uint8Array(65536);
                // Data segment
                this.dataLabels = {};
                this.output = '';
                this.pc = 0;
                this.instructions = [];
                this.running = false;
                this.instructions = [];
                this.running = false;
                this.errors = []; // Compilation errors
                this.isCompiled = false;
            }

            // Get 8-bit register value
            getReg8(name) {
                name = name.toUpperCase();
                if (name === 'AL') return this.regs.AX & 0xFF;
                if (name === 'AH') return (this.regs.AX >> 8) & 0xFF;
                if (name === 'BL') return this.regs.BX & 0xFF;
                if (name === 'BH') return (this.regs.BX >> 8) & 0xFF;
                if (name === 'CL') return this.regs.CX & 0xFF;
                if (name === 'CH') return (this.regs.CX >> 8) & 0xFF;
                if (name === 'DL') return this.regs.DX & 0xFF;
                if (name === 'DH') return (this.regs.DX >> 8) & 0xFF;
                return 0;
            }

            // Set 8-bit register
            setReg8(name, val) {
                name = name.toUpperCase();
                val = val & 0xFF;
                if (name === 'AL') this.regs.AX = (this.regs.AX & 0xFF00) | val;
                else if (name === 'AH') this.regs.AX = (this.regs.AX & 0x00FF) | (val << 8);
                else if (name === 'BL') this.regs.BX = (this.regs.BX & 0xFF00) | val;
                else if (name === 'BH') this.regs.BX = (this.regs.BX & 0x00FF) | (val << 8);
                else if (name === 'CL') this.regs.CX = (this.regs.CX & 0xFF00) | val;
                else if (name === 'CH') this.regs.CX = (this.regs.CX & 0x00FF) | (val << 8);
                else if (name === 'DL') this.regs.DX = (this.regs.DX & 0xFF00) | val;
                else if (name === 'DH') this.regs.DX = (this.regs.DX & 0x00FF) | (val << 8);
            }

            // Get register or immediate value
            getValue(operand) {
                operand = operand.trim().toUpperCase();
                // 16-bit registers
                if (['AX', 'BX', 'CX', 'DX', 'SI', 'DI', 'SP', 'BP'].includes(operand)) {
                    return this.regs[operand];
                }
                // 8-bit registers
                if (['AL', 'AH', 'BL', 'BH', 'CL', 'CH', 'DL', 'DH'].includes(operand)) {
                    return this.getReg8(operand);
                }
                // Hex number
                if (operand.endsWith('H')) {
                    return parseInt(operand.slice(0, -1), 16);
                }
                // Binary number
                if (operand.endsWith('B')) {
                    return parseInt(operand.slice(0, -1), 2);
                }
                // Decimal number
                if (/^\d+$/.test(operand)) {
                    return parseInt(operand, 10);
                }
                // Character literal
                if (operand.startsWith("'") && operand.endsWith("'")) {
                    return operand.charCodeAt(1);
                }
                // Label reference
                if (this.dataLabels[operand] !== undefined) {
                    return this.dataLabels[operand];
                }
                return 0;
            }

            // Set register value
            setValue(dest, val) {
                dest = dest.trim().toUpperCase();
                if (['AX', 'BX', 'CX', 'DX', 'SI', 'DI', 'SP', 'BP'].includes(dest)) {
                    this.regs[dest] = val & 0xFFFF;
                } else if (['AL', 'AH', 'BL', 'BH', 'CL', 'CH', 'DL', 'DH'].includes(dest)) {
                    this.setReg8(dest, val);
                }
            }

            // Update flags based on result
            updateFlags(result, is16bit = true) {
                const max = is16bit ? 0xFFFF : 0xFF;
                const signBit = is16bit ? 0x8000 : 0x80;
                this.flags.ZF = (result & max) === 0 ? 1 : 0;
                this.flags.SF = (result & signBit) ? 1 : 0;
                this.flags.CF = result > max ? 1 : 0;
                // Parity flag (count of 1s in low byte)
                let ones = 0;
                let lb = result & 0xFF;
                while (lb) { ones += lb & 1; lb >>= 1; }
                this.flags.PF = (ones % 2 === 0) ? 1 : 0;
            }

            // Find similar opcode using Levenshtein distance
            findSimilarOpcode(input, validOpcodes) {
                let bestMatch = null;
                let bestDistance = Infinity;

                for (const opcode of validOpcodes) {
                    const distance = this.levenshtein(input, opcode);
                    if (distance < bestDistance && distance <= 2) { // Max 2 edits
                        bestDistance = distance;
                        bestMatch = opcode;
                    }
                }
                return bestMatch;
            }

            // Levenshtein distance algorithm
            levenshtein(a, b) {
                const matrix = [];
                for (let i = 0; i <= b.length; i++) {
                    matrix[i] = [i];
                }
                for (let j = 0; j <= a.length; j++) {
                    matrix[0][j] = j;
                }
                for (let i = 1; i <= b.length; i++) {
                    for (let j = 1; j <= a.length; j++) {
                        if (b.charAt(i - 1) === a.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i - 1][j - 1] + 1, // substitution
                                matrix[i][j - 1] + 1,     // insertion
                                matrix[i - 1][j] + 1      // deletion
                            );
                        }
                    }
                }
                return matrix[b.length][a.length];
            }

            // Parse and execute
            parse(code) {
                this.reset();
                const lines = code.split('\n');
                const codeLines = [];
                const labels = {};
                let dataMode = false;

                // Pre-pass: Handle EQU constants and strip EMU8086 directives
                const constants = {};
                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i].split(';')[0].trim();
                    if (line.startsWith('#')) continue; // Ignore EMU8086 directives

                    // Handle EQU: NAME EQU VALUE
                    const equMatch = line.match(/^(\w+)\s+EQU\s+(.+)$/i);
                    if (equMatch) {
                        constants[equMatch[1].toUpperCase()] = equMatch[2].trim();
                        lines[i] = ''; // Remove EQU line from code
                    }
                }

                // First pass: find labels and data
                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i].split(';')[0].trim(); // Remove comments
                    if (!line || line.startsWith('#')) continue;

                    // Substitute constants
                    for (const [name, val] of Object.entries(constants)) {
                        const regex = new RegExp(`\\b${name}\\b`, 'g');
                        line = line.replace(regex, val);
                    }

                    // Check for data definitions (DB, DW)
                    const dataMatch = line.match(/^(\w+)?\s*(DB|DW)\s+(.+)$/i);
                    if (dataMatch) {
                        const label = dataMatch[1] ? dataMatch[1].toUpperCase() : null;
                        const type = dataMatch[2].toUpperCase();
                        let value = dataMatch[3].trim();

                        const addr = Object.keys(this.dataLabels).length * 256 + 0x200; // Simplified alloc
                        if (label) this.dataLabels[label] = addr;

                        // String definition
                        if (value.startsWith("'")) {
                            const strMatch = value.match(/'([^']+)'/);
                            if (strMatch) {
                                // Store string content (simplified allocation for demo)
                                // In a real allocator, we'd track 'nextFreeAddress'
                                // For now, we map label to a specific block if label exists
                                // This simple emulator unfortunately doesn't track heap well
                                // We'll stick to basic implementation for now

                                for (let j = 0; j < strMatch[1].length; j++) {
                                    this.memory[addr + j] = strMatch[1].charCodeAt(j);
                                }
                                // Handle extra bytes like 0DH, 0AH, '$'
                                const parts = value.split(',');
                                let offset = strMatch[1].length;
                                for (let p = 1; p < parts.length; p++) {
                                    let part = parts[p].trim();
                                    if (part === "'$'" || part === '"$"') {
                                        this.memory[addr + offset++] = 36; // '$'
                                    } else if (part.endsWith('H')) {
                                        this.memory[addr + offset++] = parseInt(part.slice(0, -1), 16);
                                    } else if (!isNaN(part)) {
                                        this.memory[addr + offset++] = parseInt(part, 10);
                                    }
                                }
                            }
                        } else {
                            // Numeric definition
                            if (label) this.dataLabels[label] = this.getValue(value);
                        }
                        continue;
                    }

                    // Check for code labels
                    const labelMatch = line.match(/^(\w+):/);
                    if (labelMatch) {
                        labels[labelMatch[1].toUpperCase()] = codeLines.length;
                        line = line.replace(/^(\w+):/, '').trim();
                        if (!line) continue;
                    }

                    // Handle PROC/ENDP/SEGMENT/ENDS/MACRO/ENDM
                    // Treat LABEL PROC/SEGMENT/MACRO as valid, skip line
                    if (/\s+(PROC|ENDP|SEGMENT|ENDS|MACRO|ENDM)\b/i.test(line) || /^(ENDP|ENDS|ENDM)$/i.test(line)) {
                        continue;
                    }

                    // Skip directives
                    if (/^(ORG|END|SEGMENT|ENDS|ASSUME|NAME|\.MODEL|\.DATA|\.CODE|\.STACK|\.FARDATA)/i.test(line)) {
                        continue;
                    }

                    // Clean up PTR and SHORT directives
                    line = line.replace(/\s+(BYTE|WORD|DWORD)\s+PTR\s+/gi, ' ');
                    line = line.replace(/\s+SHORT\s+/gi, ' ');

                    // Validate instruction opcode
                    const validOpcodes = ['MOV', 'ADD', 'SUB', 'MUL', 'DIV', 'INC', 'DEC', 'AND', 'OR', 'XOR', 'NOT',
                        'SHL', 'SAL', 'SHR', 'SAR', 'ROL', 'ROR', 'CMP', 'JMP', 'JZ', 'JE', 'JNZ', 'JNE', 'JC', 'JB',
                        'JNC', 'JNB', 'JAE', 'JG', 'JGE', 'JL', 'JLE', 'JA', 'JBE', 'LOOP', 'LOOPZ', 'LOOPNZ',
                        'LEA', 'PUSH', 'POP', 'XCHG', 'INT', 'RET', 'HLT', 'NOP', 'CALL', 'NEG', 'CBW', 'CWD',
                        'MOVSB', 'MOVSW', 'STOSB', 'STOSW', 'LODSB', 'LODSW', 'REP', 'REPE', 'REPNE', 'CMPSB', 'CMPSW',
                        'CLC', 'STC', 'CMC', 'CLD', 'STD', 'IN', 'OUT', 'JCXZ', 'JO', 'JP', 'JNP', 'JS',
                        'AAA', 'AAD', 'AAM', 'AAS', 'ADC', 'DAA', 'DAS', 'IDIV', 'IMUL', 'LAHF', 'SAHF', 'TEST',
                        // MACRO stubs/Common Procedures
                        'PRNSTR', 'DIS', 'PRINT_CHAR', 'PRINT_STR', 'NEWLINE', 'PRINT_LINE', 'PRINT_BORDER', 'PRINT_RESULT',
                        'GIVE_SPACE', 'PRINT_NUM', 'PRINT_DECIMAL', 'SCAN_NUM', 'SHOW_NUM', 'DEFINE_SCAN_NUM', 'DEFINE_PRINT_NUM', 'DEFINE_PRINT_NUM_UNS',
                        'SUB_HEX_TO_DEC_STR', 'SUB_EXTRACT_DIGIT', 'SUB_INT_TO_ASCII', 'ENQUEUE', 'DEQUEUE', 'CUSTOM_PUSH', 'CUSTOM_POP',
                        'GET_OPERANDS', 'READ_DECIMAL', 'CALC_FACTORIAL', 'WAIT_FOR_IDLE', 'WAIT_FOR_DATA', 'RANDOM_TURN', 'RANDOM_DECISION',
                        'PRINT_DEC_PROC', 'READ_DEC_PROC', 'PRINT_HEX_BYTE_PROC', 'PRINT_NIBBLE', 'PRINT_WORD_HEX', 'PRINT_BYTE_HEX', 'PRINT_DIGIT',
                        'DISPLAY_DIGITS', 'PRINT_ME', 'PRINT_STRING', 'PROC_M1', 'PROC_MUL', 'IF', 'ELSE', 'LOCAL', 'CHECK_ZERO', 'ADD_VALUES',
                        'MULTIPLY_POW2', 'PRINT_NEWLINE', 'M2', 'CALCULATE', 'DOUBLE_AX', 'QUADRUPLE_AX', 'ADD_NUMBERS', 'FACTORIAL', 'READ_BCD_DIGIT',
                        'DELAY_1SEC_LOOP', 'DELAY_BIOS', 'MAIN', 'DATA', 'CODE'];

                    const validDirectives = ['ORG', 'END', 'SEGMENT', 'ENDS', 'ASSUME', 'PROC', 'ENDP', '.MODEL', '.DATA', '.CODE', '.STACK', 'DB', 'DW', 'EQU', '.FARDATA'];

                    const opcode = line.split(/[\s,]+/)[0].toUpperCase();
                    if (!validOpcodes.includes(opcode) && !validDirectives.includes(opcode)) {
                        // Find similar opcode or directive for suggestion
                        const allValidTokens = [...validOpcodes, ...validDirectives];
                        const suggestion = this.findSimilarOpcode(opcode, allValidTokens);
                        const msg = suggestion
                            ? `Unknown instruction: ${opcode}. Did you mean: ${suggestion}?`
                            : `Unknown instruction: ${opcode}`;
                        this.errors.push({ line: i + 1, instruction: line, message: msg, suggestion });
                    }

                    codeLines.push({ instruction: line, lineNo: i + 1 });
                }

                this.instructions = codeLines;
                this.labels = labels;
                this.pc = 0;
            }

            // Execute one instruction
            step() {
                if (this.pc >= this.instructions.length) {
                    this.running = false;
                    return false;
                }

                const instr = this.instructions[this.pc];
                const line = instr.instruction.toUpperCase();
                const parts = line.split(/[\s,]+/).filter(p => p);
                const op = parts[0];

                try {
                    switch (op) {
                        case 'MOV':
                            this.setValue(parts[1], this.getValue(parts[2]));
                            break;

                        case 'ADD':
                            const addResult = this.getValue(parts[1]) + this.getValue(parts[2]);
                            this.setValue(parts[1], addResult);
                            this.updateFlags(addResult);
                            break;

                        case 'SUB':
                            const subResult = this.getValue(parts[1]) - this.getValue(parts[2]);
                            this.setValue(parts[1], subResult);
                            this.updateFlags(subResult);
                            this.flags.CF = subResult < 0 ? 1 : 0;
                            break;

                        case 'MUL':
                            const mulVal = this.getValue(parts[1]);
                            this.regs.AX = (this.regs.AX & 0xFF) * mulVal;
                            this.updateFlags(this.regs.AX);
                            break;

                        case 'DIV':
                            const divVal = this.getValue(parts[1]);
                            if (divVal !== 0) {
                                const quotient = Math.floor(this.regs.AX / divVal);
                                const remainder = this.regs.AX % divVal;
                                this.setReg8('AL', quotient);
                                this.setReg8('AH', remainder);
                            }
                            break;

                        case 'INC':
                            this.setValue(parts[1], this.getValue(parts[1]) + 1);
                            this.updateFlags(this.getValue(parts[1]));
                            break;

                        case 'DEC':
                            this.setValue(parts[1], this.getValue(parts[1]) - 1);
                            this.updateFlags(this.getValue(parts[1]));
                            break;

                        case 'AND':
                            const andResult = this.getValue(parts[1]) & this.getValue(parts[2]);
                            this.setValue(parts[1], andResult);
                            this.updateFlags(andResult);
                            break;

                        case 'OR':
                            const orResult = this.getValue(parts[1]) | this.getValue(parts[2]);
                            this.setValue(parts[1], orResult);
                            this.updateFlags(orResult);
                            break;

                        case 'XOR':
                            const xorResult = this.getValue(parts[1]) ^ this.getValue(parts[2]);
                            this.setValue(parts[1], xorResult);
                            this.updateFlags(xorResult);
                            break;

                        case 'NOT':
                            this.setValue(parts[1], ~this.getValue(parts[1]) & 0xFFFF);
                            break;

                        case 'SHL':
                        case 'SAL':
                            const shlResult = this.getValue(parts[1]) << this.getValue(parts[2]);
                            this.setValue(parts[1], shlResult);
                            this.updateFlags(shlResult);
                            break;

                        case 'SHR':
                            const shrResult = this.getValue(parts[1]) >>> this.getValue(parts[2]);
                            this.setValue(parts[1], shrResult);
                            this.updateFlags(shrResult);
                            break;

                        case 'CMP':
                            const cmpResult = this.getValue(parts[1]) - this.getValue(parts[2]);
                            this.updateFlags(cmpResult);
                            this.flags.CF = cmpResult < 0 ? 1 : 0;
                            break;

                        case 'JMP':
                            if (this.labels[parts[1]] !== undefined) {
                                this.pc = this.labels[parts[1]] - 1;
                            }
                            break;

                        case 'JZ':
                        case 'JE':
                            if (this.flags.ZF && this.labels[parts[1]] !== undefined) {
                                this.pc = this.labels[parts[1]] - 1;
                            }
                            break;

                        case 'JNZ':
                        case 'JNE':
                            if (!this.flags.ZF && this.labels[parts[1]] !== undefined) {
                                this.pc = this.labels[parts[1]] - 1;
                            }
                            break;

                        case 'JC':
                        case 'JB':
                            if (this.flags.CF && this.labels[parts[1]] !== undefined) {
                                this.pc = this.labels[parts[1]] - 1;
                            }
                            break;

                        case 'JNC':
                        case 'JNB':
                        case 'JAE':
                            if (!this.flags.CF && this.labels[parts[1]] !== undefined) {
                                this.pc = this.labels[parts[1]] - 1;
                            }
                            break;

                        case 'LOOP':
                            this.regs.CX--;
                            if (this.regs.CX > 0 && this.labels[parts[1]] !== undefined) {
                                this.pc = this.labels[parts[1]] - 1;
                            }
                            break;

                        case 'JCXZ':
                            if (this.regs.CX === 0 && this.labels[parts[1]] !== undefined) {
                                this.pc = this.labels[parts[1]] - 1;
                            }
                            break;

                        case 'LEA':
                            if (this.dataLabels[parts[2]] !== undefined) {
                                this.setValue(parts[1], this.dataLabels[parts[2]]);
                            }
                            break;

                        case 'PUSH':
                            this.regs.SP -= 2;
                            const pushVal = this.getValue(parts[1]);
                            this.memory[this.regs.SP] = pushVal & 0xFF;
                            this.memory[this.regs.SP + 1] = (pushVal >> 8) & 0xFF;
                            break;

                        case 'POP':
                            const popVal = this.memory[this.regs.SP] | (this.memory[this.regs.SP + 1] << 8);
                            this.setValue(parts[1], popVal);
                            this.regs.SP += 2;
                            break;

                        case 'IN':
                        case 'OUT':
                            // Stub for I/O instructions to prevent crash
                            // Real implementation would require emulating ports
                            break;

                        case 'REPE':
                        case 'REPNE':
                        case 'REPZ':
                        case 'REPNZ':
                        // Stub: treat as REP (only MOVS supported fully in this simple emulator)
                        // Future: implement ZF check distinction
                        case 'REP':
                            // Existing REP logic handles MOVSB/MOVSW
                            // We should check next instruction for CMPS etc if we want full support
                            break;

                        case 'CMPSB':
                        case 'CMPSW':
                            // Compare String - stub implementation
                            const srcIndex2 = this.regs.SI;
                            const destIndex2 = this.regs.DI;
                            const size2 = (op === 'CMPSW') ? 2 : 1;
                            // Logic similar to CMP needed here
                            if (!this.flags.DF) { this.regs.SI += size2; this.regs.DI += size2; }
                            else { this.regs.SI -= size2; this.regs.DI -= size2; }
                            break;

                        case 'XCHG':
                            const val1 = this.getValue(parts[1]);
                            const val2 = this.getValue(parts[2]);
                            this.setValue(parts[1], val2);
                            this.setValue(parts[2], val1);
                            break;

                        case 'INT':
                            this.handleInterrupt(this.getValue(parts[1]));
                            break;

                        case 'RET':
                        case 'HLT':
                            this.running = false;
                            return false;

                        case 'NOP':
                            break;

                        default:
                            // Unknown instruction - skip
                            break;
                    }
                } catch (e) {
                    this.output += '\n[Error: ' + e.message + ']';
                }

                this.pc++;
                return true;
            }

            // Handle DOS/BIOS interrupts
            handleInterrupt(num) {
                if (num === 0x21) { // DOS interrupt
                    const func = this.getReg8('AH');
                    switch (func) {
                        case 0x01: // Read char with echo
                            // Simulate input 'A'
                            this.setReg8('AL', 65);
                            break;
                        case 0x02: // Display character
                            this.output += String.fromCharCode(this.getReg8('DL'));
                            break;
                        case 0x09: // Display string
                            const addr = this.regs.DX;
                            let str = '';
                            for (let i = 0; i < 256; i++) {
                                const ch = this.memory[addr + i];
                                if (ch === 36) break; // '$' terminator
                                str += String.fromCharCode(ch);
                            }
                            this.output += str;
                            break;
                        case 0x4C: // Terminate
                            this.running = false;
                            break;
                    }
                } else if (num === 0x10) { // BIOS Video
                    // Simplified video handling
                } else if (num === 0x16) { // BIOS Keyboard
                    // Simulate key press
                    this.setReg8('AL', 13); // Enter key
                }
            }

            // Run all instructions
            run() {
                this.running = true;
                let iterations = 0;
                while (this.running && iterations < 10000) {
                    if (!this.step()) break;
                    iterations++;
                }
                if (iterations >= 10000) {
                    this.output += '\n[Execution limit reached]';
                }
            }
        }

        // Global emulator instance
        const emu = new Emulator8086();

        // Program categories and files - All 161 programs
        const programs = {
            'Addressing Modes': ['comprehensive_8086_addressing_modes_reference.asm'],
            'Arithmetic': ['add_array_of_bytes_from_memory.asm', 'addition_16bit_packed_bcd.asm', 'addition_16bit_simple.asm', 'addition_16bit_with_carry_detection.asm', 'addition_8bit_with_user_input.asm', 'calculate_sum_of_first_n_natural_numbers.asm', 'count_set_bits_in_16bit_binary.asm', 'decimal_adjust_after_addition_demo.asm', 'division_16bit_dividend_by_8bit_divisor.asm', 'generate_multiplication_table_for_number.asm', 'multiplication_8bit_unsigned.asm', 'signed_addition_and_subtraction_demo.asm', 'subtraction_8bit_with_user_input.asm', 'swap_two_numbers_using_registers.asm'],
            'Array Operations': ['calculate_sum_of_array_elements.asm', 'copy_block_of_data_between_arrays.asm', 'count_odd_and_even_numbers_in_array.asm', 'delete_element_from_array_by_index.asm', 'find_maximum_element_in_array.asm', 'find_minimum_element_in_array.asm', 'insert_element_into_array_at_index.asm'],
            'Bitwise Operations': ['bitwise_and_logic_demonstration.asm', 'bitwise_logical_shift_left_and_multiplication.asm', 'bitwise_logical_shift_right_and_division.asm', 'bitwise_not_ones_complement_demonstration.asm', 'bitwise_or_logic_demonstration.asm', 'bitwise_rotate_left_circular_shift.asm', 'bitwise_rotate_right_circular_shift.asm', 'bitwise_xor_logic_demonstration.asm'],
            'Control Flow': ['conditional_branching_and_status_flags.asm', 'for_loop_counter_iteration_pattern.asm', 'if_then_else_conditional_logic_structure.asm', 'loop_instruction_cx_register_control.asm', 'switch_case_multiway_branching_logic.asm', 'unconditional_jump_and_program_redirection.asm', 'while_loop_pre_test_conditional_iteration.asm'],
            'Conversion': ['celsius_fahrenheit_temperature_converter.asm', 'convert_decimal_to_binary_representation.asm', 'convert_decimal_to_octal_representation.asm', 'convert_hexadecimal_to_decimal_string.asm', 'convert_hexadecimal_to_packed_bcd.asm', 'convert_packed_bcd_to_hexadecimal.asm', 'hex_to_seven_segment_decoder_lookup.asm', 'reverse_digits_of_integer_value.asm', 'string_comparison_lexicographical_check.asm', 'string_copy_using_manual_loop_iteration.asm', 'string_copy_using_movsb_instruction.asm'],
            'Data Structures': ['queue.asm', 'stack_array.asm'],
            'Expression': ['average_of_array.asm', 'calculator.asm', 'check_even_odd.asm', 'count_vowels.asm', 'count_words.asm', 'factorial.asm', 'fibonacci.asm', 'gcd_two_numbers.asm', 'power.asm', 'prime_number_check.asm', 'reverse_array.asm', 'string_concatenation.asm', 'substring_search.asm'],
            'External Devices': ['keyboard.asm', 'led_display_test.asm', 'mouse.asm', 'robot.asm', 'stepper_motor.asm', 'thermometer.asm', 'timer.asm', 'traffic_lights.asm', 'traffic_lights_advanced.asm'],
            'File Operations': ['create_file.asm', 'delete_file.asm', 'read_file.asm', 'write_file.asm'],
            'Flags': ['carry_flag.asm', 'overflow_flag.asm', 'parity_flag.asm', 'sign_flag.asm', 'zero_flag.asm'],
            'Graphics': ['colored_text.asm', 'draw_line.asm', 'draw_pixel.asm', 'draw_rectangle.asm'],
            'Input Output': ['display_binary.asm', 'display_decimal.asm', 'display_hex.asm', 'read_number.asm'],
            'Interrupts': ['bios_cursor_position.asm', 'bios_keyboard.asm', 'bios_system_time.asm', 'bios_video_mode.asm', 'dos_display_char.asm', 'dos_display_string.asm', 'dos_read_char.asm', 'dos_read_string.asm'],
            'Introduction': ['data_definition_demo.asm', 'display_characters.asm', 'display_string_direct.asm', 'display_system_time.asm', 'hello_world_dos.asm', 'hello_world_interrupt.asm', 'hello_world_procedure.asm', 'hello_world_procedure_advanced.asm', 'hello_world_string.asm', 'hello_world_vga.asm', 'keyboard_wait_input.asm', 'mov_instruction_demo.asm', 'print_alphabets.asm', 'procedure_demo.asm', 'procedure_multiplication.asm'],
            'Macros': ['conditional_macros.asm', 'macro_with_parameters.asm', 'nested_macros.asm', 'print_string_macro.asm'],
            'Mathematics': ['armstrong_number.asm', 'lcm.asm', 'perfect_number.asm', 'square_root.asm', 'twos_complement.asm'],
            'Matrix': ['matrix_addition.asm', 'matrix_transpose.asm'],
            'Memory Operations': ['block_copy.asm', 'memory_compare.asm', 'memory_fill.asm', 'memory_scan.asm'],
            'Patterns': ['diamond_pattern.asm', 'inverted_triangle.asm', 'number_pyramid.asm', 'triangle_pattern.asm'],
            'Procedures': ['basic_procedure.asm', 'local_variables.asm', 'nested_procedures.asm', 'procedure_parameters.asm', 'recursive_factorial.asm'],
            'Searching': ['binary_search.asm', 'character_occurrences_count.asm', 'linear_search.asm', 'search_element_array.asm'],
            'Simulation': ['fire_monitoring_system.asm', 'garment_defect.asm', 'water_level_controller.asm'],
            'Sorting': ['array_ascending.asm', 'array_descending.asm', 'bubble_sort.asm', 'insertion_sort.asm', 'selection_sort.asm'],
            'Stack Operations': ['push_pop.asm', 'reverse_string_stack.asm', 'swap_using_stack.asm'],
            'String Operations': ['palindrome_check.asm', 'string_length.asm', 'string_reverse.asm', 'to_lowercase.asm', 'to_uppercase.asm'],
            'Utilities': ['beep_sound.asm', 'clear_screen.asm', 'delay_timer.asm', 'display_date.asm', 'password_input.asm']
        };

        // Initialize program list
        function initProgramList() {
            const container = document.getElementById('program-list');
            for (const [category, files] of Object.entries(programs)) {
                const div = document.createElement('div');
                div.className = 'category';
                div.innerHTML = `
                    <div class="category-header" onclick="this.parentElement.classList.toggle('open')">${category} (${files.length})</div>
                    <div class="category-items">
                        ${files.map(f => `<div class="program-item" onclick="loadProgram('${category}', '${f}')">${f.replace('.asm', '').replace(/_/g, ' ')}</div>`).join('')}
                    </div>
                `;
                container.appendChild(div);
            }
        }

        // Load program from GitHub
        async function loadProgram(category, filename) {
            document.getElementById('current-file').textContent = filename;
            document.getElementById('status').textContent = 'Loading...';
            document.getElementById('status').className = 'status';

            try {
                const url = `https://raw.githubusercontent.com/Amey-Thakur/8086-ASSEMBLY-LANGUAGE-PROGRAMS/main/Source%20Code/${encodeURIComponent(category)}/${filename}`;
                const response = await fetch(url);
                if (response.ok) {
                    const code = await response.text();
                    document.getElementById('code-editor').value = code;
                    document.getElementById('status').textContent = 'Loaded: ' + filename;
                    document.getElementById('status').className = 'status success';
                    resetEmulator();
                    updateLineNumbers(); // Update line numbers after loading
                    // Note: User must manually compile after loading, as requested
                } else {
                    document.getElementById('status').textContent = 'Failed to load file';
                    document.getElementById('status').className = 'status error';
                }
            } catch (e) {
                document.getElementById('status').textContent = 'Error: ' + e.message;
                document.getElementById('status').className = 'status error';
            }
        }

        // Compile code (parse and check for errors)
        function compileCode() {
            try {
                const code = document.getElementById('code-editor').value;
                if (!code.trim()) {
                    document.getElementById('status').textContent = 'Error: No code to compile';
                    document.getElementById('status').className = 'status error';
                    return false;
                }
                emu.reset();
                emu.parse(code);

                // Check for compilation errors
                if (emu.errors.length > 0) {
                    const firstError = emu.errors[0];
                    document.getElementById('status').textContent =
                        `Error on line ${firstError.line}: ${firstError.message}`;
                    document.getElementById('status').className = 'status error';
                    return false;
                }

                if (emu.instructions.length === 0) {
                    document.getElementById('status').textContent = 'Warning: No executable instructions found';
                    document.getElementById('status').className = 'status error';
                    return false;
                }

                document.getElementById('status').textContent = 'Compiled successfully! ' + emu.instructions.length + ' instructions ready.';
                document.getElementById('status').className = 'status success';
                emu.isCompiled = true;
                updateDisplay();
                return true;
            } catch (e) {
                document.getElementById('status').textContent = 'Compilation Error: ' + e.message;
                document.getElementById('status').className = 'status error';
                emu.isCompiled = false;
                return false;
            }
        }

        // Run code
        function runCode() {
            if (!emu.isCompiled) {
                document.getElementById('status').textContent = 'Error: Please compile the code first!';
                document.getElementById('status').className = 'status error';
                return;
            }
            emu.run();
            updateDisplay();
            document.getElementById('status').textContent = 'Execution complete';
            document.getElementById('status').className = 'status success';
        }

        // Step through code
        function stepCode() {
            if (!emu.isCompiled) {
                document.getElementById('status').textContent = 'Error: Please compile the code first!';
                document.getElementById('status').className = 'status error';
                return;
            }
            if (emu.step()) {
                updateDisplay();
                document.getElementById('status').textContent = 'Step: Line ' + (emu.pc);
            } else {
                document.getElementById('status').textContent = 'Execution complete';
                document.getElementById('status').className = 'status success';
            }
        }

        // Reset emulator
        function resetEmulator() {
            emu.reset();
            userScrolledOutput = false; // Reset scroll tracking for fresh output
            updateDisplay();
            document.getElementById('status').textContent = 'Ready';
            document.getElementById('status').className = 'status';
        }

        // Update line numbers and highlight active line
        function updateLineNumbers(activeLineIndex) {
            const editor = document.getElementById('code-editor');
            const gutter = document.getElementById('line-numbers');
            if (!editor || !gutter) return;

            const lineCount = editor.value.split('\n').length;
            let html = '';
            for (let i = 0; i < lineCount; i++) {
                const isActive = (i === activeLineIndex) ? ' active' : '';
                html += `<div class="line-number${isActive}">${i + 1}</div>`;
            }
            gutter.innerHTML = html;
        }

        // Sync scroll
        function syncScroll() {
            const editor = document.getElementById('code-editor');
            const gutter = document.getElementById('line-numbers');
            if (editor && gutter) {
                gutter.scrollTop = editor.scrollTop;
            }
        }

        // Copy code
        function copyCode() {
            const code = document.getElementById('code-editor').value;
            navigator.clipboard.writeText(code).then(() => {
                const btn = document.querySelector('button[title="Copy to Clipboard"]');
                if (btn) {
                    const originalText = btn.innerHTML;
                    btn.innerHTML = '‚úÖ Copied!';
                    setTimeout(() => btn.innerHTML = originalText, 2000);
                }
            });
        }

        // Download code
        function downloadCode() {
            const code = document.getElementById('code-editor').value;
            const filename = document.getElementById('current-file').textContent || 'program.asm';
            const blob = new Blob([code], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Initialize with default content
        updateLineNumbers();

        // Track whether user has manually scrolled up in the output console
        let userScrolledOutput = false;

        // Update display
        function updateDisplay() {
            // Registers
            for (const reg of ['AX', 'BX', 'CX', 'DX', 'SI', 'DI', 'SP', 'BP']) {
                document.getElementById('reg-' + reg.toLowerCase()).textContent =
                    emu.regs[reg].toString(16).toUpperCase().padStart(4, '0');
            }
            // Flags
            for (const flag of ['CF', 'ZF', 'SF', 'OF', 'PF', 'AF']) {
                const el = document.getElementById('flag-' + flag.toLowerCase());
                el.className = 'flag' + (emu.flags[flag] ? ' set' : '');
            }
            // Output - with proper auto-scroll like CMD behavior
            const outputEl = document.getElementById('output');
            const previousScrollHeight = outputEl.scrollHeight;
            outputEl.textContent = emu.output || '(No output)';

            // Auto-scroll to bottom only if user hasn't manually scrolled up
            // This mimics CMD behavior: auto-scroll by default, but respect user's scroll position
            if (!userScrolledOutput) {
                outputEl.scrollTop = outputEl.scrollHeight;
            }
        }

        // Initialize output scroll tracking after DOM is ready
        (function initOutputScrollTracking() {
            const outputEl = document.getElementById('output');
            if (!outputEl) return;

            // Track user scroll interactions on the output console
            outputEl.addEventListener('scroll', function () {
                // Check if user is at the bottom (within 20px threshold)
                const isAtBottom = outputEl.scrollHeight - outputEl.scrollTop <= outputEl.clientHeight + 20;

                // If user scrolls to bottom, resume auto-scroll
                // If user scrolls up, pause auto-scroll
                userScrolledOutput = !isAtBottom;
            });

            // Handle mousewheel scroll - detect when user actively scrolls up
            outputEl.addEventListener('wheel', function (e) {
                // If scrolling up and not already at top, user is manually scrolling
                if (e.deltaY < 0 && outputEl.scrollTop > 0) {
                    userScrolledOutput = true;
                }
                // If scrolling down toward bottom, check if we're at bottom after scroll
                // This is handled by the 'scroll' event listener above
            });
        })();

        // Theme toggle
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            document.getElementById('theme-icon').textContent = newTheme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
            localStorage.setItem('8086-theme', newTheme);
        }

        // Load saved theme
        (function () {
            const savedTheme = localStorage.getItem('8086-theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            if (document.getElementById('theme-icon')) {
                document.getElementById('theme-icon').textContent = savedTheme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
            }
        })();

        // Initialize
        initProgramList();
    </script>
</body>

</html>